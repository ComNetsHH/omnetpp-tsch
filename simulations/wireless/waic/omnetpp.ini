[General]
num-rngs = 10
check-signals = false # remove this and change modules accordingly
*.cmdenv-log-level=detail
**.result-recording-modes=default,-histogram
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 7

include common.ini
include delay_testing.ini
#include avionic.ini

**.sf.timeout = 35000ms
**.macMaxBE = 5 # maximum backoff exponent should correspond to the SF timeout value

# Lukas' scenarios
[Config _6tischEvaluationBase]
network = SixtischEvaluation
sim-time-limit = ${simLimit = 1000s}
repeat = 10
*.numHosts = 1

**.sink[0].mobility.typename = "StationaryMobility"
**.host[0].mobility.typename = "StationaryMobility"
*.sink[0].mobility.initialX = 20m
*.sink[0].mobility.initialY = 30m
*.host[0].mobility.initialX = 30m
*.host[0].mobility.initialY = 30m

**.sf.timeout = 60000ms

**.rpl.daoEnabled = false
**.numApps = 1
**.app[0].startTime = ${appStart = 50s}
**.app[0].stopTime = ${simLimit} - 100s

**.sf.maxNumCells = 100

**.sf.lowerCellUsageLimit = -1
**.sf.upperCellUsageLimit = 0.9

#[Config DelayTestMD1]
#extends = _6tischEvaluationBase
#sim-time-limit = 5000s
#warmup-period = 2000s
#result-dir = DelayTestMD1
#**.sf.maxNumCells = 250
#**.sf.lowerCellUsageLimit = ${limCellUsedLow = -1} # , 0.2, 0.4, 0.5
#**.sf.upperCellUsageLimit = ${limCellUsedHigh = 0.5, 0.75, 0.9}
#*.host[0].app[0].sendInterval = exponential(1s/${l = 1..10})
#**.app[0].stopTime = 5000s 
#
#[Config DelayTestDD1]
#extends = DelayTestMD1
#result-dir = DelayTestDD1
#
#*.host[0].app[0].sendInterval = 1s/${l}
#
#[Config LossyLinkTest]
#result-dir = LossyLink
#
##warmup-period = ${warmup = 500s}
#repeat = 10
#extends = _6tischEvaluationBase
#
#**.sf.upperCellUsageLimit = 1.1 # do not try to add cells, since it may cause schedule reset
#**.sf.initialNumCells = 5 # number of cells to schedule initially with preferred parent
#
#*.host[0].app[0].sendInterval = 2s # keep lambda moderate to decrease number of TX cells required
## stop before the end of the simulation to receive queued packets 
#*.host[0].app[0].stopTime = this.startTime + 1000s # send ~500 packets
#
#sim-time-limit = ${simTimeLimit = 2000s} # enough to trasmit any queued packets					    
#*.sink[0].app[0].stopTime = ${simTimeLimit} # sink is active until the very end, receiving queued packets 
#
#**.mac.pLinkCollision = ${pc = 0.2..0.8 step 0.1}
#**.mac.lossyLinkTimeout = ${appStart}
#**.mac.macMaxFrameRetries = ${rtxThresh = 0..7}
#**.queueLength = 3500 # no packets are lost due to queue overflow
#
[Config MsfAdaptation]
extends = _6tischEvaluationBase
result-dir = MsfAdaptation

**.mac.macMaxFrameRetries = 0
**.sf.upperCellUsageLimit = 0.75 # add cells sparsely
**.sf.lowerCellUsageLimit = -1 # do not delete cells
**.sf.maxNumCells = ${maxCells = 20..100 step 20}
**.sf.cellsToAdd = ${cellToAdd = 1..5}
*.host[0].app[0].sendInterval = 1s/${l = 5..15}
*.host[0].app[0].stopTime = ${simLimit} - 50s

# Cheng-Wei's Scenarios
[Config _TopologyEvaluationBase]
network = TopologyEvaluation
repeat = 50
sim-time-limit = 1400s
warmup-period = 1000s

**.wlan[*].radio.transmitter.power = 0.001273mW
include waic_radio.ini

*.sink*.rpl.startDelay = 10

**.mac.ignoreBitErrors = true
**.sf.send6pDelayed = false
**.macSlotframeSize = ${sl = 101}

**.ipv6.neighbourDiscovery.addRandomDelays = false

#**.sf.showLinkResets = true
**.sf.showQueueSize = true
**.sf.showTxCellCount = true
**.sf.lowerCellUsageLimit = 0.2
**.sf.upperCellUsageLimit = 0.8
# number of "extra" cells to propose in 6P ADD/RELOCATE requests,
# given the default CELL_TO_ADD = 1, setting this to 4 will result in a cell list proposal of size 5
**.sf.cellListRedundancy = 4 
**.sf.maxNumCells = intuniform(100, 110)

**.sf.clearQueueOnReset = true

**.rpl.daoEnabled = false
**.numApps = 1
**.host[*].app[0].startTime = uniform(100, 103) * 1s
*.sink[*].app[0].startTime = 100s

#*.host[*].app[0].sendInterval = (${sl}/100) / ${l = 0.5, 1, 2, 5, 10} * 1s
*.host[*].app[0].sendInterval = (${sl}/100) / ${l = 1} * 1s

#*.host[*].app[0].sendInterval = 3000s

**.constraintAreaMaxX = 500m

[Config Linear]
result-dir = result_linear
extends = _TopologyEvaluationBase

**.sf.flushQueueOnAdd = true

**.radio.receiver.snirThreshold = 3dB

*.numHosts = ${hosts = 1, 5, 8, 10, 20, 50, 100}

# record fail/success of the "last" 6P request required for stability condition
#*.host[1].**.sf.trackFailed6pAddByNum = int(ceil(${l} * (${hosts} - 1))) + 1

# serves as an achor for topology
*.sink[0].mobility.initialX = ${sinkX = 10m}
*.sink[0].mobility.initialY = ${sinkY = 30m}
*.sink[0].mobility.typename = "StationaryMobility"

*.host[*].mobility.typename = "StaticLinearMobility"
*.host[*].mobility.separation = ${sep = 4m}
*.host[*].mobility.initialX = ${sinkX} + ${sep}
*.host[*].mobility.initialY = ${sinkY}

[Config Ring]
extends = Linear
result-dir = result_ring

**.radio.receiver.snirThreshold = 3dB
**.wlan[*].radio.transmitter.power = 0.000473mW

*.host[1].**.sf.trackFailed6pAddByNum = int(ceil(${l} * (int(floor(${hosts}/2))))) + 1

*.sink[0].mobility.initialY = ${sinkY} + 1m
*.sink[0].mobility.initialX = ${sinkX} + (${sep}) * ${hosts} / 2 + 1.25m

[Config Star]
result-dir = result_star
extends = _TopologyEvaluationBase
*.numHosts = ${hosts = 5, 20, 50, 60, 100}

*.sink[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.typename = "StationaryMobility"

*.host[1].**.sf.trackFailed6pAddByNum = int(ceil(${l})) + 1

**.radio.transmitter.power = 2mW # so that all nodes reach the sink, creating a logical "star"
**.radio.receiver.snirThreshold = 0dB

*.sink[0].mobility.constraintAreaMaxX = ${maxX = 100}m
*.sink[0].mobility.constraintAreaMaxY = ${maxY = 100}m
*.host[*].mobility.constraintAreaMaxX = ${maxX}m
*.host[*].mobility.constraintAreaMaxY = ${maxY}m
*.host[*].mobility.initialX = uniform(0, ${maxX}) * 1m
*.host[*].mobility.initialY = uniform(0, ${maxY}) * 1m

*.sink[0].mobility.initialX = ${maxX} / 2 * 1m + 20m
*.sink[0].mobility.initialY = ${maxY} / 2 * 1m + 20m

[Config Mesh2D]
extends = _TopologyEvaluationBase
repeat = 20
result-dir = results_mesh

*.numHosts = ${numHostsMesh = 4, 9, 16, 25, 36} # a^2

**.nsForwardingDelay = 5s

# disable host[0] completely cause it overlaps with the sink topology-wise
*.host[0].rpl.disabled = true
*.host[0].**.sf.disable = true
*.host[0].app[0].startTime = 99999s

**.sink[*].mobility.typename = "StaticGridMobility"
**.host[*].mobility.typename = "StaticGridMobility"
**.mobility.numHosts = ${numHostsMesh}

**.mobility.constraintAreaMinX = 20m
**.mobility.constraintAreaMinY = 20m
**.mobility.constraintAreaMaxX = 60m
**.mobility.constraintAreaMaxY = 60m

**.radio.receiver.snirThreshold = ${6, 3, 3, 0, 2 ! numHostsMesh}dB

**.transmitter.power = ${0.1, 0.01, 0.005, 0.003, 0.002 ! numHostsMesh}mW

[Config SampleScenarioLukas]
network = Generic
repeat = 30
*.numHosts = ${N = 1, 2, 3}
*.sink[0].mobility.initialX = 10m
*.sink[0].mobility.initialY = 10m
*.host[0].mobility.initialX = 20m
*.host[0].mobility.initialY = 10m
*.host[1].mobility.initialX = 30m
*.host[1].mobility.initialY = 10m
*.host[2].mobility.initialX = 40m
*.host[2].mobility.initialY = 10m

**.mac.macMaxFrameRetries = 3

**.numApps = 1 # each module has only 1 app
**.app[0].startTime = uniform(20s, 30s) # give some warmup period for 6TiSCH scheduling and RPL 
**.host[*].app[0].sendInterval = exponential(1s) # poissonian arrivals

[Config AltimeterTesting]
extends = Linear

include waic_radio.ini

*.numAltimeters = 1

**.radioMedium.analogModel.typename = "WaicDimensionalAnalogModel"

*.radioAltimeter[*].mobility.constraintAreaMinX = 0m
*.radioAltimeter[*].mobility.constraintAreaMinY = 0m
*.radioAltimeter[*].mobility.constraintAreaMaxX = 100m
*.radioAltimeter[*].mobility.constraintAreaMaxY = 150m
*.radioAltimeter[*].mobility.initialX = 3m
*.radioAltimeter[*].mobility.initialY = 11m
*.radioAltimeter[*].mobility.initFromDisplayString = false

*.radioAltimeter[*].**.rpl.disabled = true
*.radioAltimeter[*].**.sf.disabled = true
*.radioAltimeter[*].numApps = 0

[Config MutualRequests]
network = TopologyEvaluation

**.ipv6.neighbourDiscovery.raEnabled = false
**.ipv6.neighbourDiscovery.skipDad = true
**.ipv6.neighbourDiscovery.addRandomDelays = true

*.numHosts = 1
**.numApps = 2

**.sf.timeout = 60000ms

**.app[*].messageLength = 50B

*.host[0].app[1].typename = "UdpSink"
*.host[0].app[1].localPort = 1001

*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].sendInterval = 0.1s

*.sink[0].numApps = 2
*.sink[0].app[1].typename = "UdpBasicApp"
*.sink[0].app[1].destAddresses = "host[0](ipv6)"
*.sink[0].app[1].destPort = 1001
*.sink[0].app[1].sendInterval = 0.1s
**.app[*].startTime = 100s

*.sink[0].mobility.typename = "StationaryMobility"
*.sink[0].mobility.initialX = 10m
*.sink[0].mobility.initialY = 10m

*.host[0].mobility.typename = "StationaryMobility"
*.host[0].mobility.initialX = 14m
*.host[0].mobility.initialY = 10m

[Config HPQ]
network = HighDensity
repeat = 28
sim-time-limit = 400s
warmup-period = 200s
**.queueUtilization.result-recording-modes = -
**.result-recording-modes = -histogram # some weird bit error histogram often crashes the simulation at the end

result-dir = HPQ_On

**.radio.transmitter.power = 0.000073mW 
include waic_radio.ini

**.wrrEnabled = true

**.daoEnabled = false
**.minHopRankIncrease = 1

*.numHosts = ${numHosts = 50, 200}
*.numSinks = ${numSinks = 1, 3, 5} # only use more than one sink for 200 nodes!

**.queueLength = 20

# MSF params
**.sf.numMinCells = 10
**.sf.maxNumCells = intuniform(40, 50) # intuniform(10, 15)
**.sf.queueEstimationPeriod = uniform(10s, 20s)
**.sf.showTxCellCount = true
**.sf.showQueueUtilization = true
**.sf.send6pDelayed = false
**.sf.showDedicatedTxCells = false
**.sf.upperCellUsageLimit = 0.9 # add cells only when utilization is really high
**.sf.lowerCellUsageLimit = -1 # do not remove cells
**.sf.queueUtilUpperThresh = 0.8
**.sf.deleteOverlappingMinCells = false # keep minimal cells even if they overlap with auto cell
**.sf.disableHousekeeping = true
**.sf.housekeepingPeriod = 10s


# Topology (aircraft seats imitation)
*.radioAltimeter.mobility.constraintAreaMinX = 0m
*.radioAltimeter.mobility.constraintAreaMinY = 0m
*.radioAltimeter.mobility.constraintAreaMaxX = 100m
*.radioAltimeter.mobility.constraintAreaMaxY = 150m
*.radioAltimeter.mobility.initialX = 3m
*.radioAltimeter.mobility.initialY = 11m
*.radioAltimeter.mobility.initFromDisplayString = false

*.radioAltimeter.**.rpl.disabled = true
*.radioAltimeter.**.sf.disabled = true

include seatbelts_layout.ini

## Apps
*.radioAltimeter.numApps = 0
**.numApps = 3

*.sink[*].app[*].typename = "UdpSink"
*.sink[*].app[*].localPort = 1000 + index()
*.sink[*].app[*].startTime = ${startTime = 100}s

**.sf.housekeepingStart = ${startTime} 

*.host[*].app[*].typename = "TschUdpBasicApp"
*.host[*].app[*].destPort = 1000 + index()
*.host[*].app[*].destAddresses = "sink[0](ipv6)"
*.host[*].app[*].messageLength = 50B

# Seatbelt status
*.host[*].app[0].VirtualLinkID = 1 # low prio
*.host[*].app[0].startTime = uniform(${startTime}, ${startTime} + 10) * 1s

# Humidity
*.host[*].app[2].VirtualLinkID = 0 # normal prio

# Smoke
*.host[*].app[1].VirtualLinkID = -1 # high prio
*.host[*].app[1].sendInterval = 2s # was 2s
*.host[*].app[1].stopTime = this.startTime + 120s # let bursty traffic run for only a few min


# only selected nodes have smoke sensors / humidity monitoring active, depending on the topology
# uncomment depending on the $numNodes param
#include hpq_50.ini
include hpq_200.ini

# disable smoke and humidity sensors on all other nodes
*.host[*].app[1].startTime = 20h
*.host[*].app[2].startTime = 20h

[Config HPQ_Off]
extends = HPQ
result-dir = HPQ_Off
*.host[*].app[0].VirtualLinkID = 0
*.host[*].app[1].VirtualLinkID = 0
*.host[*].app[2].VirtualLinkID = 0


[Config ReSA]
network = ReSa
repeat = 10
sim-time-limit = ${simtime = 5000}s
warmup-period = ${warmup = 1000}s
result-dir = ReSa_dummy
**.vector-recording = true

**.numDaoRetransmitAttempts = 20

include ReSa.ini
include waic_radio.ini

#**.ipv6.neighbourDiscovery.typename = "Ipv6NeighbourDiscoveryWireless"
**.ipv6.neighbourDiscovery.raEnabled = false
**.ipv6.neighbourDiscovery.skipDad = true
**.ipv6.neighbourDiscovery.addRandomDelays = true

**.sf.timeout = 40000ms

**.gw*.rpl.startDelay = 10

#**.macSlotframeSize = 137
#**.macMaxFrameRetries = 5

#**.sf.upperCellUsageLimit = 1.1 # no cell addition
#**.sf.lowerCellUsageLimit = -1 # no cell deletion

#**.rpl.minHopRankIncrease = 10 # do not change parents

**.nsForwardingDelay = 1s

*.sos*[*].app[0].startTime = uniform(${warmup}s, ${simtime}s - 500s)
*.sos*[*].app[0].sendInterval = ${simtime}s

**.app[*].startTime = ${warmup}s # give enough time for CLX second phase

*.sos*[*].app[0].startTime.param-record-as-scalar = true

[Config ReSA-CLX]
extends = ReSA
result-dir=ReSA-CLX
repeat = 20
**.sf.typename = "TschCLSF"
**.rpl.crossLayerEnabled = true
**.rpl.clPhase2Timeout = ${warmup} - 200















 