[Config _TestBase]
network = Generic
warmup-period = ${warmup = 200}s
sim-time-limit = ${simtime = 1200s}
**.daoEnabled = false # we don't need downlink messages
**.daoAckEnabled = false

# Do not add or delete cells at all
**.sf.lowerCellUsageLimit = -1
**.sf.upperCellUsageLimit = 1.1
#**.sf.showQueueUtilization = true
**.sf.showTxCellCount = true # display number of scheduled dedicated TX cells above node in GUI
**.sf.handleRankUpdates = true # needed to schedule pre-calculated amount of uplink cells to handle the traffic
#**.sf.queueRecordingPeriod = ${queueRecPeriod = 0.2, 1}

# Mobility (straight line)
*.sink[*].mobility.initialX = 15m
*.sink[*].mobility.initialY = 20m

**.queueLength = 9999 # no packets are lost due to queue overflow

# Cleaning up IPv6 neighbor discovery clutter
**.ipv6.neighbourDiscovery.raEnabled = false
**.ipv6.neighbourDiscovery.skipDad = true
**.ipv6.neighbourDiscovery.addRandomDelays = true

**.sf.showQueueSize = true
**.sf.disableHousekeeping = false
**.channelHopping.useRandomPattern = true
#**.channelHopping.pattern = "17" # disabled hopping
**.mac.ignoreBitErrors = true
**.mac.macMaxFrameRetries = 0
**.macSlotframeSize = ${sfSize = 101}
**.sf.numMinCells = 2

*.host[*].mobility.typename = "StaticGridMobility"
**.mobility.constraintAreaMaxX = 120m
*.host[*].mobility.constraintAreaMinX = 17m
*.host[*].mobility.constraintAreaMinY = 10m
*.host[*].mobility.numHosts = 10
*.host[*].mobility.columns = 10
*.host[*].mobility.rows = 1
*.host[*].mobility.marginX = 5m
*.host[*].mobility.separationX = 10m
*.host[*].mobility.separationY = 20m

# Apps
*.host[*].numApps = 1
*.host[*].app[*].startTime = uniform(${warmup}s - 100s, ${warmup}s - 90s) # some warmup period
*.sink[*].app[*].startTime = ${warmup}s - 100s
*.sink[*].app[*].typename = "UdpSink"

**host[*].app[*].typename = "TschUdpBasicApp"

#*.lambda = ${l = 0.7, 1, 2, 3, 5} # traffic rate, same for all hosts
#*.lambda = ${l = 0.1..1 step 0.1} # traffic rate, same for all hosts

#**.app**.result-recording-modes= default
#**.mac**.interarrivalTime.result-recording-modes= default
#**.mac**.pktEnqueued.result-recording-modes= default
#**.result-recording-modes= -

**.sink**app**.endToEndDelay.result-recording-modes= default
**.result-recording-modes= -

[Config Debugging]
extends = _TestBase
*.numHosts = 1

*.sink[*].numApps = 0
*.lambda = 5
*.host[*].app[*].sendInterval = 10s
*.host[*].app[*].stopTime = ${simtime} - 500s

[Config _DelayTestAppBase]
# To measure e2e delay for each node, its application connects to unique port/application at the sink 
*.sink[*].numApps = ${N}
*.sink[*].app[*].localPort = 1000 + index()
*.host[*].app[0].destPort = 1000 + parentIndex()
*.host[*].app[*].sendInterval = exponential(${sfSize}/100 / ${l}) * 1s # poissonian arrivals
*.host[*].app[*].stopTime = ${simtime} - 100s

[Config DelayTest_MD1]
description = Simulating a sequence of MD1 queues
extends = _TestBase, _DelayTestAppBase
result-dir = DelayTest_MD1
repeat = 10
*.numHosts = ${N=1, 2, 3, 4, 7, 9}
*.lambda = ${l = 0.5, 1..10} # traffic rate, same for all hosts

[Config DelayTest_DD1]
description = Simulating a sequence of DD1 queues
extends = DelayTest_MD1
result-dir = DelayTest_DD1
repeat = 200
*.host[*].app[*].sendInterval = ${sfSize}/100 / ${l} * 1s # deterministic arrivals with period T = slotframe_duration (in seconds) / arrival_rate
#*.host[0].app[*].stopTime = this.startTime + 1s
*.host[*].app[*].stopTime = ${simtime} - 10s



[Config Schedule_generator_test]
extends = DelayTest_DD1
description = sample config to test schedule generator

**.sf.disable = true
*.host[0].**.mac.schedule.fileName = "./generated_schedules/Schedule_generator_test/host_0.xml"
*.sink[*].**.mac.schedule.fileName = "./generated_schedules/Schedule_generator_test/sink.xml"

[Config _Infocom_Single_Hop_Base]
extends = _TestBase
repeat = 20

measurement-label = l=${l}
output-vector-file = ${resultdir}/${configname}_l=${l}-${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_l=${l}-${repetition}.sca

*.numHosts = 1
*.host[0].app[0].sendInterval = ${sfSize}/100 / ${l} * 1s # deterministic arrivals with period T = slotframe_duration (in seconds) / arrival_rate
*.host[0].app[0].stopTime = ${simtime} - 50s

[Config BroadTree]
extends = DelayTest_DD1
result-dir = BroadTree
warmup-period = 700s
repeat = 20
*.numHosts = 9
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.constraintAreaMinX = 0
*.host[*].mobility.constraintAreaMinY = 0

**.transmitter.power = 0.005mW
**.sf.handleRankUpdates = false # disable pre-computed scheduling of TX cells per node
**.sf.upperCellUsageLimit = 0.9
**.sf.lowerCellUsageLimit = 0.45
**.sf.numMinCells = 7

*.host[*].app[*].stopTime = ${simtime} - 1s

# rank 1
*.host[0].mobility.initialX = 10m
*.host[0].mobility.initialY = 25m
*.host[8].mobility.initialX = 20m
*.host[8].mobility.initialY = 25m

# rank 2
*.host[1].mobility.initialX = 3m
*.host[2].mobility.initialX = 5m
*.host[1].mobility.initialY = 33m
*.host[2].mobility.initialY = 33m
*.host[3].mobility.initialX = 7m
*.host[4].mobility.initialX = 9m
*.host[3].mobility.initialY = 33m
*.host[4].mobility.initialY = 33m

# rank 3
*.host[5].mobility.initialX = 16m
*.host[6].mobility.initialX = 17m
*.host[7].mobility.initialX = 18m
*.host[5].mobility.initialY = 43m
*.host[6].mobility.initialY = 42m
*.host[7].mobility.initialY = 41m

[Config BroadTree_Overprovisioning_Test]
extends = BroadTree
result-dir = BroadTree_Overprovisioning_Test

**.sf.upperCellUsageLimit = ${up = 0.9, 0.9, 0.6}
**.sf.lowerCellUsageLimit = ${down = 0.4, 0.45, 0.45 ! up}

[Config BroadTree_Queue_Size_Impact]
**.result-recording-modes = default

extends = BroadTree
result-dir = BroadTree_Q_Impact

# throw in Poisson traffic to add more variability
*.host[*].app[0].sendInterval = exponential(${sfSize}/100 / ${l} * 1s)

**.sf.upperCellUsageLimit = ${up = 0.9, 0.9, 0.6}
**.sf.lowerCellUsageLimit = ${down = 0.4, 0.45, 0.45 ! up}

**.queueLength = ${qSize = 5, 20, 100}


[Config BroadTree_Poisson]
extends = BroadTree
result-dir = BroadTree_Poisson
*.host[*].app[0].sendInterval = exponential(${sfSize}/100 / ${l} * 1s)

# set cell util limits wider for leaf nodes to avoid having single TX cell 
*.host[1..3].**.sf.lowerCellUsageLimit = 0.1
*.host[5..8].**.sf.lowerCellUsageLimit = 0.1

# or also extreme overprovisioning
*.host[1..3].**.sf.upperCellUsageLimit = 0.95
*.host[5..8].**.sf.upperCellUsageLimit = 0.95

**.queueLength = 20


[Config Infocom_Service_Time_Validation]
extends = _Infocom_Single_Hop_Base
result-dir = Infocom_Service_Time_Validation
*.lambda = ${l = 0.1..0.9 step 0.1}

[Config Infocom_Single_Hop_Validation]
extends = _Infocom_Single_Hop_Base
result-dir = Infocom_Single_Hop
*.lambda = ${l = 1..10}

[Config Infocom_Single_Hop_Validation_Poisson]
extends = _Infocom_Single_Hop_Base
result-dir = Infocom_Single_Hop_Poisson
*.lambda = ${l = 0.1..0.9 step 0.1}
*.host[0].app[0].sendInterval = exponential(${sfSize}/100 / ${l}) * 1s 

[Config Infocom_Multihop_Poisson]
extends = _TestBase, _DelayTestAppBase
repeat = 10
result-dir = Infocom_Multihop_Poisson

*.numHosts = ${N = 7}
*.lambda = ${l = 0.5, 1, 1.5, 2}

measurement-label = l=${l}, n=${N}
output-vector-file = ${resultdir}/${configname}_n=${N}_l=${l}-${repetition}.vec
output-scalar-file = ${resultdir}/${configname}_n=${N}_l=${l}-${repetition}.sca

[Config _CellMatchingTestbedBase]
extends = _TestBase, _DelayTestAppBase
result-dir = CellMatching
warmup-period = 800s
repeat = 20

**.sf.handleRankUpdates = false # force nodes to adapt to traffic 1 cell at a time
**.mac.ignoreBitErrors = false
**.sf.upperCellUsageLimit = 0.9
**.sf.maxNumCells = 30

**.host[*].numApps = 0
# sink doesn't request any cells itself, but has to pick the first ones offered to it in CELL_LISTs
*.sink[*].**.sf.cellMatchingEnabled = true 
*.host[*].app[*].startTime = 100s
*.host[*].app[*].startTime = ${simtime} - 1s
*.host[*].app[*].stopTime = ${simtime}

*.sink[*].numApps = 1
*.sink[*].app[0].typename = "WaicUdpSink" # to record jitter

[Config CellMatchingTestbed_2_hops]
extends = _CellMatchingTestbedBase
*.numHosts = ${N=2}
*.host[1].numApps = 1
**.host[0].**.cellMatchingEnabled = ${cellMatched = true, false}
*.sink[*].app[0].localPort = 1001

[Config CellMatchingTestbed_4_hops]
extends = _CellMatchingTestbedBase
*.numHosts = ${N=4}
*.host[3].numApps = 1
**.host[0..2].**.cellMatchingEnabled = ${cellMatched = true, false}
*.sink[*].app[0].localPort = 1003

[Config CellMatchingTestbed_10_hops]
extends = _CellMatchingTestbedBase
*.numHosts = ${N=10}
*.host[9].numApps = 1
**.host[0..8].**.cellMatchingEnabled = ${cellMatched = true, false}
*.sink[*].app[0].localPort = 1009

[Config CellMatchingTestbed_10_hops_reduced]
extends = _CellMatchingTestbedBase
*.numHosts = ${N=10}
*.host[9].numApps = 1
**.host[0].**.cellMatchingEnabled = ${cellMatched = true, false}
**.host[8].**.cellMatchingEnabled = ${cellMatched}
*.sink[*].app[0].localPort = 1009

[Config Infocom_Lossy_Link]
extends = _Infocom_Single_Hop_Base
result-dir = Infocom_Lossy_Link
*.lambda = ${l = 0.1..0.9 step 0.1}
**.mac.pLinkCollision = ${pc=0.1..0.9 step 0.1}
**.mac.macMaxFrameRetries = 100
**.lossyLinkTimeout = ${warmup}s

measurement-label = l=${l}, pc=${pc}

output-vector-file = "${resultdir}/${configname}_pc=${pc}_l=${l}-${repetition}.vec"
output-scalar-file = "${resultdir}/${configname}_pc=${pc}_l=${l}-${repetition}.sca"

[Config DelayTest_DD1_Lossy]
extends = DelayTest_DD1
result-dir = DelayTest_DD1_Lossy
repeat = 10
**.mac.pLinkCollision = ${pc=0.1..0.9 step 0.1}
**.mac.macMaxFrameRetries = ${rtxThresh = 3, 5, 10, 15, 20, 50, 100}
**.lossyLinkTimeout = ${warmup}s

output-vector-file = "${resultdir}/${configname}_pc=${pc}_l=${l}-${repetition}_rtx=${rtxThresh}.vec"
output-scalar-file = "${resultdir}/${configname}_pc=${pc}_l=${l}-${repetition}_rtx=${rtxThresh}.sca"

**.sink**.app**.endToEndDelay.result-recording-modes = default
**.result-recording-modes = -

[Config DD1_Lossy_Utilization_Test]
extends = DelayTest_DD1_Lossy
result-dir = DelayTest_DD1_Lossy_Utilization_Test
# predefined service rate
**.sf.handleRankUpdates = false
**.sf.initialNumCells = 10 

[Config DD1_Lossy_Single_Tx]
extends = DelayTest_DD1_Lossy
result-dir = DD1_Lossy_Single_Tx
repeat = 10
**.app**.sendInterval = 400s # arbitrary high enough value so that packets surely won't queue 
**.sf.handleRankUpdates = false
**.sf.initialNumCells = ${m = 1, 3}

output-vector-file = "${resultdir}/${configname}_pc=${pc}_m=${m}_${repetition}.vec"
output-scalar-file = "${resultdir}/${configname}_pc=${pc}_m=${m}_${repetition}.sca"

