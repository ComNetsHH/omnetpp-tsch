*.sink[*].mobility.constraintAreaMinX = ${minX = 2m}
*.sink[*].mobility.constraintAreaMaxX = 40m

*.host[*].mobility.typename = "FlexibleGridMobility"
*.host[*].mobility.numHosts = ${hostsPerGroup = int(${numHosts} / 2)}
*.host[*].mobility.columns = ${cols = 3}
*.host[*].mobility.marginX = 0
*.host[*].mobility.marginY = 0
*.host[*].mobility.separationX = ${sepX = 0.5m}
*.host[*].mobility.separationY = ${sepY = 1.25m}

*.host[*].mobility.resetRowAtNodeIndex = ${hostsPerGroup}
 
*.host[*].mobility.constraintAreaMinX = parentIndex() < ${hostsPerGroup} ? ${minX} : (${minX} + ${sepX} * (${cols} + 1))  
*.host[*].mobility.constraintAreaMaxX = this.constraintAreaMinX + ${sepX} * ${cols}

**.host[*].mobility.constraintAreaMinY = 2m
**.host[*].mobility.constraintAreaMaxY = this.constraintAreaMinY + ${sepY} * (int(${hostsPerGroup} / ${cols}))

**.sink[*].mobility.constraintAreaMinY = 2m
**.sink[*].mobility.constraintAreaMaxY = this.constraintAreaMinY + ${sepY} * (int(${hostsPerGroup} / ${cols}))

*.sink[*].mobility.initialX = this.constraintAreaMinX + ${sepX} * ${cols}
*.sink[0].mobility.initialY = ${centerY=this.constraintAreaMinY + (1 + pow(-1, ${numSinks}-1)) * ${sepY}/2 * int(${hostsPerGroup} / ${cols}) / 2 + (1 + pow(-1, ${numSinks})) * (this.constraintAreaMaxY - this.constraintAreaMinY) / ${numSinks} / 4}
*.sink[*].mobility.initialY = ${centerY} + ( (1 + pow(-1, ${numSinks}-1))/2 * (int((parentIndex() - 1) / 2) + 1) + (1 + pow(-1, ${numSinks}))/2 * parentIndex() ) * pow( pow(-1, ${numSinks}) , parentIndex()) * (this.constraintAreaMaxY - this.constraintAreaMinY) / ${numSinks} + 0.8 * ${sepY} * (1 + pow(-1, ${numSinks}-1))/2


#*.sink[*].mobility.initialX = this.constraintAreaMinX + ${sepX} * ${cols}
#*.sink[0].mobility.initialY = ${middleY = this.constraintAreaMinY + ${sepY} * int(${hostsPerGroup} / ${cols}) / 2}
#*.sink[*].mobility.initialY = ${middleY} + (int((parentIndex() - 1) / 2) + 1) * pow(-1, parentIndex()) * (this.constraintAreaMaxY - this.constraintAreaMinY) / ${numSinks} + 0.8 * ${sepY}



