*.sink[*].mobility.constraintAreaMinX = ${minX = 2m}
*.sink[*].mobility.constraintAreaMaxX = 40m

*.host[*].mobility.typename = "FlexibleGridMobility"
*.host[*].mobility.numHosts = ${perGroup = int(${hosts} / 2)}
*.host[*].mobility.columns = ${cols = 3}
*.host[*].mobility.marginX = 0
*.host[*].mobility.marginY = 0
*.host[*].mobility.separationX = ${pX = 0.5m}
*.host[*].mobility.separationY = ${pY = 1.25m}

*.host[*].mobility.resetRowAtNodeIndex = ${perGroup}
 
*.host[*].mobility.constraintAreaMinX = parentIndex() < ${perGroup} ? ${minX} : (${minX} + ${pX} * (${cols} + 1))  
*.host[*].mobility.constraintAreaMaxX = this.constraintAreaMinX + ${pX} * ${cols}

**.host[*].mobility.constraintAreaMinY = 2m
**.host[*].mobility.constraintAreaMaxY = this.constraintAreaMinY + ${pY} * (int(${perGroup} / ${cols}))

**.sink[*].mobility.constraintAreaMinY = 2m
**.sink[*].mobility.constraintAreaMaxY = this.constraintAreaMinY + ${pY} * (int(${perGroup} / ${cols}))

*.sink[*].mobility.initialX = this.constraintAreaMinX + ${pX} * ${cols}
*.sink[0].mobility.initialY = ${oY=this.constraintAreaMinY + (1 + pow(-1, ${sinks}-1)) * ${pY}/2 * int(${perGroup} / ${cols}) / 2 + (1 + pow(-1, ${sinks})) * (this.constraintAreaMaxY - this.constraintAreaMinY) / ${sinks} / 4}
*.sink[*].mobility.initialY = ${oY} + ( (1 + pow(-1, ${sinks}-1))/2 * (int((parentIndex() - 1) / 2) + 1) + (1 + pow(-1, ${sinks}))/2 * parentIndex() ) * pow( pow(-1, ${sinks}) , parentIndex()) * (this.constraintAreaMaxY - this.constraintAreaMinY) / ${sinks} + 0.8 * ${pY} * (1 + pow(-1, ${sinks}-1))/2

# legend: pX - padding X-axis, oX - center of the grid on X-axis, perGroup - number of hosts per group (seats divided by the central corridor)